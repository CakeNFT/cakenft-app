/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
} from "ethers";
import {
  Contract,
  ContractTransaction,
  Overrides,
  CallOverrides,
} from "@ethersproject/contracts";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";

interface ICakeNFTStoreInterface extends ethers.utils.Interface {
  functions: {
    "acceptOffer(address,uint256,uint256)": FunctionFragment;
    "accumulativeCakeOf(address,uint256)": FunctionFragment;
    "auction(address,uint256,uint256,uint256)": FunctionFragment;
    "auctionWithPermit(address,uint256,uint256,uint256,uint256,uint8,bytes32,bytes32)": FunctionFragment;
    "bid(address,uint256,uint256)": FunctionFragment;
    "buy(address,uint256)": FunctionFragment;
    "cake()": FunctionFragment;
    "cakeStaker()": FunctionFragment;
    "cancelAuction(address,uint256)": FunctionFragment;
    "cancelOffer(address,uint256,uint256)": FunctionFragment;
    "cancelSale(address,uint256)": FunctionFragment;
    "checkAuction(address,uint256)": FunctionFragment;
    "checkSelling(address,uint256)": FunctionFragment;
    "claim(address,uint256)": FunctionFragment;
    "claimCake(address,uint256)": FunctionFragment;
    "claimableCakeOf(address,uint256)": FunctionFragment;
    "claimedCakeOf(address,uint256)": FunctionFragment;
    "offer(address,uint256,uint256)": FunctionFragment;
    "sell(address,uint256,uint256)": FunctionFragment;
    "sellWithPermit(address,uint256,uint256,uint256,uint8,bytes32,bytes32)": FunctionFragment;
    "set(address,uint256,uint256)": FunctionFragment;
    "stakedCakeBalances(address,uint256)": FunctionFragment;
    "totalStakedCakeBalance()": FunctionFragment;
    "userMint(address)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "acceptOffer",
    values: [string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "accumulativeCakeOf",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "auction",
    values: [string, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "auctionWithPermit",
    values: [
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "bid",
    values: [string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "buy",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "cake", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "cakeStaker",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "cancelAuction",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelOffer",
    values: [string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelSale",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "checkAuction",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "checkSelling",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "claim",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "claimCake",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "claimableCakeOf",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "claimedCakeOf",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "offer",
    values: [string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "sell",
    values: [string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "sellWithPermit",
    values: [
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "set",
    values: [string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "stakedCakeBalances",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "totalStakedCakeBalance",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "userMint", values: [string]): string;

  decodeFunctionResult(
    functionFragment: "acceptOffer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "accumulativeCakeOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "auction", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "auctionWithPermit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "bid", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "buy", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "cake", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "cakeStaker", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "cancelAuction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelOffer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "cancelSale", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "checkAuction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "checkSelling",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "claim", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "claimCake", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "claimableCakeOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimedCakeOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "offer", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "sell", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "sellWithPermit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "set", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "stakedCakeBalances",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalStakedCakeBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "userMint", data: BytesLike): Result;

  events: {
    "AcceptOffer(address,uint256,uint256,address)": EventFragment;
    "Auction(address,uint256,address,uint256,uint256)": EventFragment;
    "Bid(address,uint256,address,uint256)": EventFragment;
    "Buy(address,uint256,address,uint256)": EventFragment;
    "CancelAuction(address,uint256,address)": EventFragment;
    "CancelOffer(address,uint256,uint256,address)": EventFragment;
    "CancelSale(address,uint256,address)": EventFragment;
    "Claim(address,uint256,address,uint256)": EventFragment;
    "ClaimCake(address,uint256,address,uint256)": EventFragment;
    "DistributeCake(address,uint256)": EventFragment;
    "Offer(address,uint256,uint256,address,uint256)": EventFragment;
    "Sell(address,uint256,address,uint256)": EventFragment;
    "UserMint(address,uint256,address,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AcceptOffer"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Auction"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Bid"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Buy"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CancelAuction"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CancelOffer"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CancelSale"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Claim"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ClaimCake"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DistributeCake"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Offer"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Sell"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserMint"): EventFragment;
}

export class ICakeNFTStore extends Contract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  on(event: EventFilter | string, listener: Listener): this;
  once(event: EventFilter | string, listener: Listener): this;
  addListener(eventName: EventFilter | string, listener: Listener): this;
  removeAllListeners(eventName: EventFilter | string): this;
  removeListener(eventName: any, listener: Listener): this;

  interface: ICakeNFTStoreInterface;

  functions: {
    acceptOffer(
      nft: string,
      nftId: BigNumberish,
      offerId: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "acceptOffer(address,uint256,uint256)"(
      nft: string,
      nftId: BigNumberish,
      offerId: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    accumulativeCakeOf(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    "accumulativeCakeOf(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    auction(
      nft: string,
      nftId: BigNumberish,
      startPrice: BigNumberish,
      endBlock: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "auction(address,uint256,uint256,uint256)"(
      nft: string,
      nftId: BigNumberish,
      startPrice: BigNumberish,
      endBlock: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    auctionWithPermit(
      nft: string,
      nftId: BigNumberish,
      startPrice: BigNumberish,
      endBlock: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "auctionWithPermit(address,uint256,uint256,uint256,uint256,uint8,bytes32,bytes32)"(
      nft: string,
      nftId: BigNumberish,
      startPrice: BigNumberish,
      endBlock: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    bid(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "bid(address,uint256,uint256)"(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    buy(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "buy(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    cake(overrides?: Overrides): Promise<ContractTransaction>;

    "cake()"(overrides?: Overrides): Promise<ContractTransaction>;

    cakeStaker(overrides?: Overrides): Promise<ContractTransaction>;

    "cakeStaker()"(overrides?: Overrides): Promise<ContractTransaction>;

    cancelAuction(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "cancelAuction(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    cancelOffer(
      nft: string,
      nftId: BigNumberish,
      offerId: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "cancelOffer(address,uint256,uint256)"(
      nft: string,
      nftId: BigNumberish,
      offerId: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    cancelSale(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "cancelSale(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    checkAuction(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "checkAuction(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    checkSelling(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "checkSelling(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    claim(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "claim(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    claimCake(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "claimCake(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    claimableCakeOf(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    "claimableCakeOf(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    claimedCakeOf(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    "claimedCakeOf(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    offer(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "offer(address,uint256,uint256)"(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    sell(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "sell(address,uint256,uint256)"(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    sellWithPermit(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "sellWithPermit(address,uint256,uint256,uint256,uint8,bytes32,bytes32)"(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    set(
      nft: string,
      staking: BigNumberish,
      fee: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "set(address,uint256,uint256)"(
      nft: string,
      staking: BigNumberish,
      fee: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    stakedCakeBalances(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    "stakedCakeBalances(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    totalStakedCakeBalance(overrides?: CallOverrides): Promise<[BigNumber]>;

    "totalStakedCakeBalance()"(overrides?: CallOverrides): Promise<[BigNumber]>;

    userMint(nft: string, overrides?: Overrides): Promise<ContractTransaction>;

    "userMint(address)"(
      nft: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;
  };

  acceptOffer(
    nft: string,
    nftId: BigNumberish,
    offerId: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "acceptOffer(address,uint256,uint256)"(
    nft: string,
    nftId: BigNumberish,
    offerId: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  accumulativeCakeOf(
    nft: string,
    nftId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "accumulativeCakeOf(address,uint256)"(
    nft: string,
    nftId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  auction(
    nft: string,
    nftId: BigNumberish,
    startPrice: BigNumberish,
    endBlock: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "auction(address,uint256,uint256,uint256)"(
    nft: string,
    nftId: BigNumberish,
    startPrice: BigNumberish,
    endBlock: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  auctionWithPermit(
    nft: string,
    nftId: BigNumberish,
    startPrice: BigNumberish,
    endBlock: BigNumberish,
    deadline: BigNumberish,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "auctionWithPermit(address,uint256,uint256,uint256,uint256,uint8,bytes32,bytes32)"(
    nft: string,
    nftId: BigNumberish,
    startPrice: BigNumberish,
    endBlock: BigNumberish,
    deadline: BigNumberish,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  bid(
    nft: string,
    nftId: BigNumberish,
    price: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "bid(address,uint256,uint256)"(
    nft: string,
    nftId: BigNumberish,
    price: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  buy(
    nft: string,
    nftId: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "buy(address,uint256)"(
    nft: string,
    nftId: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  cake(overrides?: Overrides): Promise<ContractTransaction>;

  "cake()"(overrides?: Overrides): Promise<ContractTransaction>;

  cakeStaker(overrides?: Overrides): Promise<ContractTransaction>;

  "cakeStaker()"(overrides?: Overrides): Promise<ContractTransaction>;

  cancelAuction(
    nft: string,
    nftId: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "cancelAuction(address,uint256)"(
    nft: string,
    nftId: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  cancelOffer(
    nft: string,
    nftId: BigNumberish,
    offerId: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "cancelOffer(address,uint256,uint256)"(
    nft: string,
    nftId: BigNumberish,
    offerId: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  cancelSale(
    nft: string,
    nftId: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "cancelSale(address,uint256)"(
    nft: string,
    nftId: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  checkAuction(
    nft: string,
    nftId: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "checkAuction(address,uint256)"(
    nft: string,
    nftId: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  checkSelling(
    nft: string,
    nftId: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "checkSelling(address,uint256)"(
    nft: string,
    nftId: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  claim(
    nft: string,
    nftId: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "claim(address,uint256)"(
    nft: string,
    nftId: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  claimCake(
    nft: string,
    nftId: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "claimCake(address,uint256)"(
    nft: string,
    nftId: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  claimableCakeOf(
    nft: string,
    nftId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "claimableCakeOf(address,uint256)"(
    nft: string,
    nftId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  claimedCakeOf(
    nft: string,
    nftId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "claimedCakeOf(address,uint256)"(
    nft: string,
    nftId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  offer(
    nft: string,
    nftId: BigNumberish,
    price: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "offer(address,uint256,uint256)"(
    nft: string,
    nftId: BigNumberish,
    price: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  sell(
    nft: string,
    nftId: BigNumberish,
    price: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "sell(address,uint256,uint256)"(
    nft: string,
    nftId: BigNumberish,
    price: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  sellWithPermit(
    nft: string,
    nftId: BigNumberish,
    price: BigNumberish,
    deadline: BigNumberish,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "sellWithPermit(address,uint256,uint256,uint256,uint8,bytes32,bytes32)"(
    nft: string,
    nftId: BigNumberish,
    price: BigNumberish,
    deadline: BigNumberish,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  set(
    nft: string,
    staking: BigNumberish,
    fee: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "set(address,uint256,uint256)"(
    nft: string,
    staking: BigNumberish,
    fee: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  stakedCakeBalances(
    nft: string,
    nftId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "stakedCakeBalances(address,uint256)"(
    nft: string,
    nftId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  totalStakedCakeBalance(overrides?: CallOverrides): Promise<BigNumber>;

  "totalStakedCakeBalance()"(overrides?: CallOverrides): Promise<BigNumber>;

  userMint(nft: string, overrides?: Overrides): Promise<ContractTransaction>;

  "userMint(address)"(
    nft: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  callStatic: {
    acceptOffer(
      nft: string,
      nftId: BigNumberish,
      offerId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "acceptOffer(address,uint256,uint256)"(
      nft: string,
      nftId: BigNumberish,
      offerId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    accumulativeCakeOf(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "accumulativeCakeOf(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    auction(
      nft: string,
      nftId: BigNumberish,
      startPrice: BigNumberish,
      endBlock: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "auction(address,uint256,uint256,uint256)"(
      nft: string,
      nftId: BigNumberish,
      startPrice: BigNumberish,
      endBlock: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    auctionWithPermit(
      nft: string,
      nftId: BigNumberish,
      startPrice: BigNumberish,
      endBlock: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    "auctionWithPermit(address,uint256,uint256,uint256,uint256,uint8,bytes32,bytes32)"(
      nft: string,
      nftId: BigNumberish,
      startPrice: BigNumberish,
      endBlock: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    bid(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "bid(address,uint256,uint256)"(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    buy(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "buy(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    cake(overrides?: CallOverrides): Promise<string>;

    "cake()"(overrides?: CallOverrides): Promise<string>;

    cakeStaker(overrides?: CallOverrides): Promise<string>;

    "cakeStaker()"(overrides?: CallOverrides): Promise<string>;

    cancelAuction(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "cancelAuction(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    cancelOffer(
      nft: string,
      nftId: BigNumberish,
      offerId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "cancelOffer(address,uint256,uint256)"(
      nft: string,
      nftId: BigNumberish,
      offerId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    cancelSale(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "cancelSale(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    checkAuction(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "checkAuction(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    checkSelling(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "checkSelling(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    claim(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "claim(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    claimCake(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "claimCake(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    claimableCakeOf(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "claimableCakeOf(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    claimedCakeOf(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "claimedCakeOf(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    offer(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "offer(address,uint256,uint256)"(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    sell(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "sell(address,uint256,uint256)"(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    sellWithPermit(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    "sellWithPermit(address,uint256,uint256,uint256,uint8,bytes32,bytes32)"(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    set(
      nft: string,
      staking: BigNumberish,
      fee: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "set(address,uint256,uint256)"(
      nft: string,
      staking: BigNumberish,
      fee: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    stakedCakeBalances(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "stakedCakeBalances(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalStakedCakeBalance(overrides?: CallOverrides): Promise<BigNumber>;

    "totalStakedCakeBalance()"(overrides?: CallOverrides): Promise<BigNumber>;

    userMint(nft: string, overrides?: CallOverrides): Promise<BigNumber>;

    "userMint(address)"(
      nft: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  filters: {
    AcceptOffer(
      nft: string | null,
      nftId: BigNumberish | null,
      offerId: BigNumberish | null,
      acceptor: null
    ): EventFilter;

    Auction(
      nft: string | null,
      nftId: BigNumberish | null,
      owner: string | null,
      startPrice: null,
      endBlock: null
    ): EventFilter;

    Bid(
      nft: string | null,
      nftId: BigNumberish | null,
      bidder: string | null,
      price: null
    ): EventFilter;

    Buy(
      nft: string | null,
      nftId: BigNumberish | null,
      buyer: string | null,
      price: null
    ): EventFilter;

    CancelAuction(
      nft: string | null,
      nftId: BigNumberish | null,
      owner: string | null
    ): EventFilter;

    CancelOffer(
      nft: string | null,
      nftId: BigNumberish | null,
      offerId: BigNumberish | null,
      offeror: null
    ): EventFilter;

    CancelSale(
      nft: string | null,
      nftId: BigNumberish | null,
      owner: string | null
    ): EventFilter;

    Claim(
      nft: string | null,
      nftId: BigNumberish | null,
      bidder: string | null,
      price: null
    ): EventFilter;

    ClaimCake(
      nft: string | null,
      nftId: BigNumberish | null,
      to: string | null,
      claimed: null
    ): EventFilter;

    DistributeCake(by: string | null, distributed: null): EventFilter;

    Offer(
      nft: string | null,
      nftId: BigNumberish | null,
      offerId: BigNumberish | null,
      offeror: null,
      price: null
    ): EventFilter;

    Sell(
      nft: string | null,
      nftId: BigNumberish | null,
      owner: string | null,
      price: null
    ): EventFilter;

    UserMint(
      nft: string | null,
      nftId: BigNumberish | null,
      minter: string | null,
      mintPrice: null
    ): EventFilter;
  };

  estimateGas: {
    acceptOffer(
      nft: string,
      nftId: BigNumberish,
      offerId: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "acceptOffer(address,uint256,uint256)"(
      nft: string,
      nftId: BigNumberish,
      offerId: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    accumulativeCakeOf(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "accumulativeCakeOf(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    auction(
      nft: string,
      nftId: BigNumberish,
      startPrice: BigNumberish,
      endBlock: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "auction(address,uint256,uint256,uint256)"(
      nft: string,
      nftId: BigNumberish,
      startPrice: BigNumberish,
      endBlock: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    auctionWithPermit(
      nft: string,
      nftId: BigNumberish,
      startPrice: BigNumberish,
      endBlock: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "auctionWithPermit(address,uint256,uint256,uint256,uint256,uint8,bytes32,bytes32)"(
      nft: string,
      nftId: BigNumberish,
      startPrice: BigNumberish,
      endBlock: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    bid(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "bid(address,uint256,uint256)"(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    buy(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "buy(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    cake(overrides?: Overrides): Promise<BigNumber>;

    "cake()"(overrides?: Overrides): Promise<BigNumber>;

    cakeStaker(overrides?: Overrides): Promise<BigNumber>;

    "cakeStaker()"(overrides?: Overrides): Promise<BigNumber>;

    cancelAuction(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "cancelAuction(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    cancelOffer(
      nft: string,
      nftId: BigNumberish,
      offerId: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "cancelOffer(address,uint256,uint256)"(
      nft: string,
      nftId: BigNumberish,
      offerId: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    cancelSale(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "cancelSale(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    checkAuction(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "checkAuction(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    checkSelling(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "checkSelling(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    claim(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "claim(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    claimCake(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "claimCake(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    claimableCakeOf(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "claimableCakeOf(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    claimedCakeOf(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "claimedCakeOf(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    offer(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "offer(address,uint256,uint256)"(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    sell(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "sell(address,uint256,uint256)"(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    sellWithPermit(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "sellWithPermit(address,uint256,uint256,uint256,uint8,bytes32,bytes32)"(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    set(
      nft: string,
      staking: BigNumberish,
      fee: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "set(address,uint256,uint256)"(
      nft: string,
      staking: BigNumberish,
      fee: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    stakedCakeBalances(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "stakedCakeBalances(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalStakedCakeBalance(overrides?: CallOverrides): Promise<BigNumber>;

    "totalStakedCakeBalance()"(overrides?: CallOverrides): Promise<BigNumber>;

    userMint(nft: string, overrides?: Overrides): Promise<BigNumber>;

    "userMint(address)"(nft: string, overrides?: Overrides): Promise<BigNumber>;
  };

  populateTransaction: {
    acceptOffer(
      nft: string,
      nftId: BigNumberish,
      offerId: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "acceptOffer(address,uint256,uint256)"(
      nft: string,
      nftId: BigNumberish,
      offerId: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    accumulativeCakeOf(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "accumulativeCakeOf(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    auction(
      nft: string,
      nftId: BigNumberish,
      startPrice: BigNumberish,
      endBlock: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "auction(address,uint256,uint256,uint256)"(
      nft: string,
      nftId: BigNumberish,
      startPrice: BigNumberish,
      endBlock: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    auctionWithPermit(
      nft: string,
      nftId: BigNumberish,
      startPrice: BigNumberish,
      endBlock: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "auctionWithPermit(address,uint256,uint256,uint256,uint256,uint8,bytes32,bytes32)"(
      nft: string,
      nftId: BigNumberish,
      startPrice: BigNumberish,
      endBlock: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    bid(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "bid(address,uint256,uint256)"(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    buy(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "buy(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    cake(overrides?: Overrides): Promise<PopulatedTransaction>;

    "cake()"(overrides?: Overrides): Promise<PopulatedTransaction>;

    cakeStaker(overrides?: Overrides): Promise<PopulatedTransaction>;

    "cakeStaker()"(overrides?: Overrides): Promise<PopulatedTransaction>;

    cancelAuction(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "cancelAuction(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    cancelOffer(
      nft: string,
      nftId: BigNumberish,
      offerId: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "cancelOffer(address,uint256,uint256)"(
      nft: string,
      nftId: BigNumberish,
      offerId: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    cancelSale(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "cancelSale(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    checkAuction(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "checkAuction(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    checkSelling(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "checkSelling(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    claim(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "claim(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    claimCake(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "claimCake(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    claimableCakeOf(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "claimableCakeOf(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    claimedCakeOf(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "claimedCakeOf(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    offer(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "offer(address,uint256,uint256)"(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    sell(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "sell(address,uint256,uint256)"(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    sellWithPermit(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "sellWithPermit(address,uint256,uint256,uint256,uint8,bytes32,bytes32)"(
      nft: string,
      nftId: BigNumberish,
      price: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    set(
      nft: string,
      staking: BigNumberish,
      fee: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "set(address,uint256,uint256)"(
      nft: string,
      staking: BigNumberish,
      fee: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    stakedCakeBalances(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "stakedCakeBalances(address,uint256)"(
      nft: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalStakedCakeBalance(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "totalStakedCakeBalance()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    userMint(nft: string, overrides?: Overrides): Promise<PopulatedTransaction>;

    "userMint(address)"(
      nft: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;
  };
}
